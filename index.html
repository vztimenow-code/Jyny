E html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jyny AI Chatbot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #030712;
            color: #e5e7eb;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-gray-950 text-white font-sans antialiased">
    <div id="app" class="flex flex-col h-screen">
        <div id="messages-container" class="flex-1 overflow-y-auto p-4 scrollbar-hide">
            <div class="flex flex-col items-center justify-center pt-8 pb-4 border-b border-gray-800">
                <h1 class="text-3xl sm:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-teal-400 via-cyan-500 to-blue-600">Jyny</h1>
                <div class="mt-2 flex items-center gap-2">
                    <p class="text-xs text-gray-500 font-mono">
                        User ID: <span id="user-id" class="text-blue-400 break-all"></span>
                    </p>
                    <button id="share-chat-button" class="text-xs text-gray-400 hover:text-white transition-colors duration-200">
                        Share Chat
                    </button>
                    <span id="copied-message" class="text-xs text-green-400 hidden">Copied!</span>
                </div>
            </div>
            <div id="chat-messages" class="max-w-3xl mx-auto py-8">
                <div id="empty-chat-message" class="text-center text-gray-500 mt-16">
                    Start a conversation with Jyny!
                </div>
            </div>
            <div id="messages-end-ref"></div>
        </div>

        <div class="p-4 border-t border-gray-800 sticky bottom-0">
            <div class="flex flex-wrap justify-center gap-2 mb-4">
                <button id="paragraph-mode" class="px-4 py-2 rounded-full font-semibold transition-colors duration-200 bg-gray-800 text-gray-200 hover:bg-gray-700" data-mode="paragraph">
                    Generate Paragraph
                </button>
                <button id="summarize-mode" class="px-4 py-2 rounded-full font-semibold transition-colors duration-200 bg-gray-800 text-gray-200 hover:bg-gray-700" data-mode="summarize">
                    Summarize Text
                </button>
                <button id="image-mode" class="px-4 py-2 rounded-full font-semibold transition-colors duration-200 bg-gray-800 text-gray-200 hover:bg-gray-700" data-mode="image">
                    Generate Image
                </button>
            </div>
            <form id="chat-form" class="max-w-3xl mx-auto flex items-center space-x-2">
                <input type="file" id="image-file-input" accept="image/*" class="hidden">
                <button type="button" id="image-upload-button" class="p-3 rounded-full shadow-lg transition-colors duration-200 bg-gray-800 text-gray-200 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L15 16m-2-12l4.586 4.586a2 2 0 012.828 0L21 12m-6-12a2 2 0 012 2v16a2 2 0 01-2 2H3a2 2 0 01-2-2V2a2 2 0 012-2h12z" />
                    </svg>
                </button>
                <input type="text" id="chat-input" placeholder="Message Jyny..." class="flex-1 p-3 rounded-full bg-gray-800 text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-600 transition-all duration-200">
                <button type="submit" id="send-button" class="p-3 bg-blue-600 text-white rounded-full shadow-lg hover:bg-blue-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14M12 5l7 7-7 7" />
                    </svg>
                </button>
            </form>
            <div id="image-file-info" class="flex items-center justify-center mt-2 text-sm text-gray-400 hidden">
                Selected: <span id="image-file-name" class="ml-1 text-gray-200"></span>
                <button id="remove-image-button" class="ml-2 text-red-500 hover:text-red-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const TEXT_MODEL = 'gemini-2.5-flash-preview-05-20';
        const TTS_MODEL = 'gemini-2.5-flash-preview-tts';
        const IMAGE_GEN_MODEL = 'imagen-3.0-generate-002';
        const API_URL_TEXT = `https://generativelanguage.googleapis.com/v1beta/models/${TEXT_MODEL}:generateContent`;
        const API_URL_TTS = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent`;
        const API_URL_IMAGE_GEN = `https://generativelanguage.googleapis.com/v1beta/models/${IMAGE_GEN_MODEL}:predict`;

        // Utility functions for TTS
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcmData, sampleRate) => {
            const dataLength = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true);
                offset += 2;
            }
            return new Blob([view], { type: 'audio/wav' });
        };

        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        // Utility function to handle markdown rendering
        const renderMarkdown = (markdown) => {
            let html = markdown.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            let result = '';
            let inCodeBlock = false;
            let codeBlockContent = '';

            const lines = html.split('\n');
            const listRegex = /^(\*|\-|\d+\.)\s/;

            lines.forEach((line, index) => {
                if (line.startsWith('```')) {
                    if (inCodeBlock) {
                        result += `<pre class="bg-gray-700 p-2 rounded-md text-sm overflow-x-auto my-2"><code class="text-gray-200">${codeBlockContent}</code></pre>`;
                        codeBlockContent = '';
                    }
                    inCodeBlock = !inCodeBlock;
                } else if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                } else {
                    if (listRegex.test(line)) {
                        const content = line.replace(listRegex, '').trim();
                        if (index > 0 && listRegex.test(lines[index - 1])) {
                            result += `<li class="ml-4 list-disc">${content}</li>`;
                        } else {
                            result += `<ul class="my-2"><li class="ml-4 list-disc">${content}</li></ul>`;
                        }
                    } else {
                        result += `<p class="my-1">${line}</p>`;
                    }
                }
            });

            if (inCodeBlock) {
                result += `<pre class="bg-gray-700 p-2 rounded-md text-sm overflow-x-auto my-2"><code class="text-gray-200">${codeBlockContent}</code></pre>`;
            }

            return result;
        };

        // DOM Elements
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');
        const messagesEndRef = document.getElementById('messages-end-ref');
        const userIdSpan = document.getElementById('user-id');
        const emptyChatMessage = document.getElementById('empty-chat-message');
        const imageFileInput = document.getElementById('image-file-input');
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageFileInfo = document.getElementById('image-file-info');
        const imageFileNameSpan = document.getElementById('image-file-name');
        const removeImageButton = document.getElementById('remove-image-button');
        const modeButtons = document.querySelectorAll('[data-mode]');
        const shareChatButton = document.getElementById('share-chat-button');
        const copiedMessage = document.getElementById('copied-message');
        const sendButton = document.getElementById('send-button');

        // State variables
        let messages = [];
        let isLoading = false;
        let db = null;
        let auth = null;
        let userId = null;
        let isTTSLoading = false;
        let imageFile = null;
        let mode = 'chat'; // 'chat', 'paragraph', 'summarize', 'image'

        // Firebase Initialization and Authentication
        window.onload = function() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        userIdSpan.textContent = userId;
                        // Start listening for chat messages only after auth
                        setupFirestoreListener();
                    } else {
                        const anonymousUser = await signInAnonymously(auth);
                        userId = anonymousUser.user.uid;
                        userIdSpan.textContent = userId;
                        setupFirestoreListener();
                    }
                });

                if (initialAuthToken) {
                    signInWithCustomToken(auth, initialAuthToken)
                        .catch((error) => {
                            console.error('Custom token sign-in failed:', error);
                            signInAnonymously(auth);
                        });
                } else {
                    signInAnonymously(auth);
                }
            } catch (e) {
                console.error('Firebase initialization error:', e);
            }
        };

        const setupFirestoreListener = () => {
            if (db && userId) {
                const chatCollectionPath = `/artifacts/${appId}/public/data/chats`;
                const q = query(collection(db, chatCollectionPath), where("userId", "==", userId));
                onSnapshot(q, (snapshot) => {
                    const fetchedMessages = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
                    const sortedMessages = fetchedMessages.sort((a, b) => a.timestamp - b.timestamp);
                    messages = sortedMessages;
                    renderMessages();
                });
            }
        };

        const renderMessages = () => {
            chatMessages.innerHTML = '';
            if (messages.length === 0) {
                emptyChatMessage.classList.remove('hidden');
            } else {
                emptyChatMessage.classList.add('hidden');
            }

            messages.forEach((msg, index) => {
                const isBot = msg.sender === 'bot';
                const msgDiv = document.createElement('div');
                msgDiv.className = `flex mb-4 ${isBot ? 'justify-start' : 'justify-end'}`;

                const contentDiv = document.createElement('div');
                contentDiv.className = `p-3 rounded-xl max-w-xl shadow-lg break-words ${isBot ? 'bg-gray-800 text-gray-200' : 'bg-blue-600 text-white'}`;

                if (msg.isLoading) {
                    contentDiv.innerHTML = `
                        <div class="flex items-center space-x-2">
                            <svg class="animate-spin h-5 w-5 text-white" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span class="font-medium">Jyny is thinking...</span>
                        </div>
                    `;
                } else if (msg.type === 'image') {
                    contentDiv.innerHTML = `
                        <div class="flex flex-col items-center">
                            <p class="text-sm italic mb-2">Image generated for "${msg.text}"</p>
                            <img src="${msg.imageUrl}" alt="${msg.text}" class="rounded-lg shadow-md max-w-full h-auto" />
                        </div>
                    `;
                } else {
                    let imageHtml = '';
                    if (msg.hasImage && msg.imageUrl) {
                        imageHtml = `
                            <div class="mb-2">
                                <img src="${msg.imageUrl}" alt="${msg.imageName}" class="rounded-lg shadow-md max-w-full h-auto" />
                            </div>
                        `;
                    }
                    contentDiv.innerHTML = `
                        ${imageHtml}
                        <div class="prose prose-invert max-w-none">
                            ${renderMarkdown(msg.text)}
                        </div>
                    `;

                    if (isBot && msg.text.length > 0) {
                        const ttsButton = document.createElement('button');
                        ttsButton.className = "mt-2 p-1.5 rounded-full bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed";
                        ttsButton.innerHTML = `<svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fill-rule="evenodd" d="M9.383 3.064A1 1 0 0110 3v14a1 1 0 01-1.383.948l-6.19-3.439A2 2 0 001 13.069V6.93a2 2 0 001.427-1.948l6.19-3.439z" clip-rule="evenodd" />
                                                </svg>`;
                        ttsButton.onclick = () => handleTextToSpeech(msg.text);
                        contentDiv.appendChild(ttsButton);
                    }
                }
                msgDiv.appendChild(contentDiv);
                chatMessages.appendChild(msgDiv);
            });
            messagesEndRef.scrollIntoView({ behavior: 'smooth' });
        };

        const handleTextToSpeech = async (text) => {
            if (isTTSLoading) return;
            isTTSLoading = true;
            try {
                const payload = {
                    contents: [{ parts: [{ text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Kore" }
                            }
                        }
                    }
                };
                const response = await fetch(API_URL_TTS, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    throw new Error(`TTS API call failed with status: ${response.status}`);
                }
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                    audio.onended = () => URL.revokeObjectURL(audioUrl);
                } else {
                    console.error("No audio data received.");
                }
            } catch (error) {
                console.error('Error generating TTS:', error);
            } finally {
                isTTSLoading = false;
            }
        };

        const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                imageFile = file;
                imageFileNameSpan.textContent = imageFile.name;
                imageFileInfo.classList.remove('hidden');
                imageUploadButton.classList.add('bg-blue-600');
                imageUploadButton.classList.remove('bg-gray-800');
            }
        };

        const removeImage = () => {
            imageFile = null;
            imageFileInput.value = null;
            imageFileInfo.classList.add('hidden');
            imageUploadButton.classList.add('bg-gray-800');
            imageUploadButton.classList.remove('bg-blue-600');
        };

        const getPlaceholderText = () => {
            switch (mode) {
                case 'paragraph': return 'Enter a topic for the paragraph...';
                case 'summarize': return 'Paste text to summarize...';
                case 'image': return 'Describe the image you want to create...';
                case 'chat':
                default: return 'Message Jyny...';
            }
        };

        const setMode = (newMode) => {
            modeButtons.forEach(btn => {
                if (btn.dataset.mode === newMode) {
                    btn.classList.add('bg-blue-600', 'text-white');
                    btn.classList.remove('bg-gray-800', 'text-gray-200', 'hover:bg-gray-700');
                } else {
                    btn.classList.remove('bg-blue-600', 'text-white');
                    btn.classList.add('bg-gray-800', 'text-gray-200', 'hover:bg-gray-700');
                }
            });
            mode = newMode;
            chatInput.placeholder = getPlaceholderText();
        };

        const setIsLoading = (loading) => {
            isLoading = loading;
            chatInput.disabled = loading;
            sendButton.disabled = loading;
            imageUploadButton.disabled = loading;
            modeButtons.forEach(btn => btn.disabled = loading);
        };

        const sendMessage = async (e) => {
            e.preventDefault();
            const trimmedInput = chatInput.value.trim();
            if ((!trimmedInput && !imageFile) || isLoading || !userId) return;
            
            setIsLoading(true);

            let userMessage;
            if (imageFile) {
                userMessage = {
                    text: trimmedInput,
                    sender: 'user',
                    timestamp: Date.now(),
                    userId: userId,
                    hasImage: true,
                    imageName: imageFile.name,
                    imageUrl: URL.createObjectURL(imageFile)
                };
            } else {
                userMessage = {
                    text: trimmedInput,
                    sender: 'user',
                    timestamp: Date.now(),
                    userId: userId
                };
            }

            const botMessagePlaceholder = {
                text: '...',
                sender: 'bot',
                timestamp: Date.now() + 1,
                isLoading: true,
                userId: userId
            };

            messages = [...messages, userMessage, botMessagePlaceholder];
            renderMessages();
            chatInput.value = '';
            removeImage();

            try {
                const chatCollectionPath = `/artifacts/${appId}/public/data/chats`;
                await addDoc(collection(db, chatCollectionPath), userMessage);
            } catch (error) {
                console.error('Error adding document to Firestore:', error);
            }

            try {
                switch (mode) {
                    case 'paragraph':
                        await handleTextGeneration(`Generate a well-written, single paragraph about: ${trimmedInput}`, 'paragraph');
                        break;
                    case 'summarize':
                        await handleTextGeneration(`Summarize the following text concisely: ${trimmedInput}`, 'summary');
                        break;
                    case 'image':
                        await handleImageGeneration(trimmedInput);
                        break;
                    case 'chat':
                    default:
                        await handleTextGeneration(trimmedInput);
                        break;
                }
            } catch (error) {
                console.error('Error during message processing:', error);
                const errorBotMessage = {
                    text: 'Error: Could not get a response.',
                    sender: 'bot',
                    timestamp: Date.now() + 2,
                    userId: userId
                };
                updateMessages(errorBotMessage);
            } finally {
                setIsLoading(false);
                setMode('chat');
            }
        };

        const handleTextGeneration = async (userText, type = 'text') => {
            try {
                const history = messages.map(msg => ({
                    role: msg.sender === 'user' ? 'user' : 'model',
                    parts: [{ text: msg.text }]
                }));
                const userParts = [{ text: userText }];

                if (imageFile) {
                    const reader = new FileReader();
                    reader.onloadend = async () => {
                        const base64Data = reader.result.split(',')[1];
                        userParts.push({
                            inlineData: {
                                mimeType: imageFile.type,
                                data: base64Data
                            }
                        });
                        await callTextAPI(history, userParts, type);
                    };
                    reader.readAsDataURL(imageFile);
                } else {
                    await callTextAPI(history, userParts, type);
                }
            } catch (error) {
                console.error('Error fetching from AI:', error);
                updateMessages({
                    text: 'Error: Could not get a response.',
                    sender: 'bot',
                    timestamp: Date.now() + 2,
                    userId: userId
                });
            }
        };

        const callTextAPI = async (history, userParts, type) => {
            const payload = {
                contents: history.concat([{ role: 'user', parts: userParts }])
            };

            const response = await fetch(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API call failed with status: ${response.status}`);
            }

            const result = await response.json();
            const botResponseText = result.candidates?.[0]?.content?.parts?.[0]?.text || 'No response from AI.';

            const botMessage = {
                text: botResponseText,
                sender: 'bot',
                timestamp: Date.now() + 2,
                userId: userId,
                type: type
            };
            updateMessages(botMessage);
        };

        const handleImageGeneration = async (prompt) => {
            try {
                const payload = {
                    instances: { prompt: prompt },
                    parameters: { sampleCount: 1 }
                };
                const response = await fetch(API_URL_IMAGE_GEN, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    throw new Error(`Image Generation API failed with status: ${response.status}`);
                }
                const result = await response.json();
                const base64Data = result?.predictions?.[0]?.bytesBase64Encoded;
                if (base64Data) {
                    const imageUrl = `data:image/png;base64,${base64Data}`;
                    const botMessage = {
                        text: prompt,
                        sender: 'bot',
                        timestamp: Date.now() + 2,
                        userId: userId,
                        type: 'image',
                        imageUrl: imageUrl
                    };
                    updateMessages(botMessage);
                } else {
                    throw new Error('No image data received.');
                }
            } catch (error) {
                console.error('Error generating image:', error);
                updateMessages({
                    text: 'Error: Could not generate image.',
                    sender: 'bot',
                    timestamp: Date.now() + 2,
                    userId: userId
                });
            }
        };

        const updateMessages = (newMessage) => {
            const placeholderIndex = messages.findIndex(msg => msg.isLoading);
            if (placeholderIndex !== -1) {
                messages[placeholderIndex] = { ...newMessage, isLoading: false };
            } else {
                messages.push(newMessage);
            }
            renderMessages();
            try {
                const chatCollectionPath = `/artifacts/${appId}/public/data/chats`;
                addDoc(collection(db, chatCollectionPath), newMessage);
            } catch (error) {
                console.error('Error adding bot message to Firestore:', error);
            }
        };
        
        const handleShareChat = () => {
            const shareUrl = `${window.location.protocol}//${window.location.host}?appId=${appId}`;
            const tempInput = document.createElement('input');
            tempInput.value = shareUrl;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            copiedMessage.classList.remove('hidden');
            setTimeout(() => {
                copiedMessage.classList.add('hidden');
            }, 2000);
        };

        // Event Listeners
        chatForm.addEventListener('submit', sendMessage);
        imageFileInput.addEventListener('change', handleImageUpload);
        removeImageButton.addEventListener('click', removeImage);
        shareChatButton.addEventListener('click', handleShareChat);
        modeButtons.forEach(button => {
            button.addEventListener('click', () => setMode(button.dataset.mode));
        });
    </script>
</body>
</html>


